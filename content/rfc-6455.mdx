---
title: "WebSocket Protocol (RFC 6455)"
date: "2011-12-01"
---

# WebSocket Protocol

[RFC 6455](https://datatracker.ietf.org/doc/html/rfc6455)는 클라이언트와 서버 간 **양방향 실시간 통신**을 위한 프로토콜을 정의합니다.
채팅, 실시간 알림, 게임 등 즉각적인 데이터 전송이 필요한 서비스의 핵심 기술입니다.

---

## 1. HTTP vs WebSocket

### 기존 HTTP의 한계
```
클라이언트 → 서버: "새 메시지 있어요?"
서버 → 클라이언트: "없어요"
(1초 후)
클라이언트 → 서버: "지금은요?"
서버 → 클라이언트: "아직 없어요"
... 반복 (Polling)
```
**문제**: 불필요한 요청이 계속 발생하고, 실시간성이 떨어집니다.

### WebSocket의 해결책
```
클라이언트 ↔ 서버: 연결 유지
서버: (메시지 도착 시) "새 메시지 왔어요!" → 즉시 전송
```
**한 번 연결하면 양쪽에서 자유롭게 메시지를 주고받을 수 있습니다.**

---

## 2. 연결 수립 과정 (Handshake)

WebSocket은 **HTTP Upgrade**를 통해 연결을 시작합니다.

### 클라이언트 요청
```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
```

### 서버 응답
```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

**101 응답** 이후부터는 HTTP가 아닌 WebSocket 프레임으로 통신합니다.

---

## 3. 브라우저 구현

```javascript
// 연결
const socket = new WebSocket('wss://example.com/chat');

// 연결 완료
socket.onopen = () => {
  console.log('연결됨!');
  socket.send('안녕하세요');
};

// 메시지 수신
socket.onmessage = (event) => {
  console.log('받은 메시지:', event.data);
};

// 연결 종료
socket.onclose = () => {
  console.log('연결 종료됨');
};

// 에러 처리
socket.onerror = (error) => {
  console.error('에러 발생:', error);
};
```

---

## 4. 주요 특징

| 특징 | 설명 |
|------|------|
| **양방향 통신** | 클라이언트와 서버 모두 먼저 메시지를 보낼 수 있음 |
| **낮은 오버헤드** | HTTP 헤더 없이 작은 프레임으로 통신 |
| **지속 연결** | 한 번 연결하면 명시적으로 닫을 때까지 유지 |
| **ws:// / wss://** | 일반/암호화 연결 (HTTPS처럼 wss:// 권장) |

---

> [!NOTE]
> **Socket.IO vs WebSocket**  
> Socket.IO는 WebSocket을 감싼 라이브러리로, 자동 재연결, 폴백(Long Polling) 등 편의 기능을 제공합니다. 순수 WebSocket만 필요하다면 네이티브 API로 충분합니다.
